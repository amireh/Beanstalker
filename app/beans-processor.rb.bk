require 'rubygems'
require 'beanstalk-client'

module Beanstalker
  class NoJobFound < Exception; end

  class BeansProcessor 
    PULLING_TIMER = 0.5

    def self.bslog(message)
      puts "| Processor: \t#{message}"
    end

    # temp tube is used for job browsing and reading purposes
    @@tmp_handle = nil
    @@connection = nil
    @@t = {}
    @@states = ["ready", "buried"]
    @@jobs = {"ready" => {}, "buried" => {}}
    # MUST call before any other
    # args: valid, active beanstalk-client connection
    def self.setHandler(connection, options)
      @@connection = connection
      #puts "-- #{@@connection.last_server} --"
      begin
        @@tmp_handle = Beanstalk::Pool.new("#{options['host']}:#{options['port']}", "temp")
        @@tmp_handle.watch("temp")
        @@tmp_handle.use("temp")
      rescue
        raise CouldNotConnect, "Could not open temp tube!"
      end
      bslog "Set up connection @ #{@@tmp_handle.last_server}, tube 'temp'"
    end

    def self.is_connected?
      return !@@connection.nil?
    end

    # returns a hash that contains all
    # information of a given job
    def self.parseJob(job)
      bslog "Parsing job and storing into hash"
      @@t["jobs"]["#{@@current_state}"]["#{job.id}"] = job.stats
    end

    # returns a hash of all jobs in current tube
    def self.parseTube(tube)
      raise NotConnected if !is_connected?
      bslog "Parsing tube #{tube}i"

      @@t ||= {} # our temp tube

      # initiate our hash
      @@t = { "jobs" =>
              { "reserved" => {}, 
                "urgent" => {}, 
                "ready" => {},
                "buried" => {},
                "delayed" => {}
              },
              "watching" => 0,
              "using" => 0,
              "waiting" => 0}
      
      # process each job in original tube &
      # store them in temp tube for later
      @@connection.use(tube)
      @@connection.watch(tube)
      data = @@connection.stats_tube(tube)
      #bslog "Data pre-manipulation: \n #{data.inspect.gsub(',', "\n")}"
      @@current_state = "ready"
      while true
        # retrieve
          job = popJob(@@connection)

        break if job.nil? # no more jobs in queue
        
        # process
          parseJob(job)
          #pushJob(@@tmp_handle, job)
          pushJob(job)

        #job.release

        # release
          #job.delete
      end
      #bslog "Done processing jobs for tube #{tube}"
      #bslog "Data pre rebuilding: \n #{@@connection.stats_tube(tube).inspect.gsub(',', "\n")}"
      #bslog "Temp hash: #{@@t.inspect}"
      rebuildTube(tube)
      #bslog "Data post manipulation: \n #{@@connection.stats_tube(tube).inspect.gsub(',', "\n")}"
      return @@t
    end

    #def self.pushJob(connection, job)
    def self.pushJob(job)
      bslog "Pushing job into #{@@connection.list_tube_used} with id #{job.id}"
      #connection.put(job.body, job.pri, job.delay, job.ttr)
      @@jobs["#{@@current_state}"]["#{job.id}"] = job unless @@jobs["#{@@current_state}"].has_key?("#{job.id}")
    end

    # gets job from front of queue
    def self.popJob(connection)
      bslog "Popping job from #{connection.list_tube_used}"
      connection.reserve(PULLING_TIMER) rescue nil

      #return (job.nil? || @@t["jobs"]["#{job.state}"].has_key?("#{job.id}")) ? nil : job
    end

    def self.rebuildTube(tube)
      @@connection.watch(tube)
      @@connection.use(tube)

      #while true
        #job = popJob(@@tmp_handle)
        #break if job.nil?
        #pushJob(@@connection, job)
      #end
      #while !@@jobs.empty?
        #@@connection.release
      #end
      return if @@jobs["#{@@current_state}"].empty?
      #for job in @@jobs do |id, j|
      @@jobs["#{@@current_state}"].each do |id, j|
        #bslog "Releasing job with id #{id} from conn #{@@connection.last_conn.inspect}"
        #@@connection.last_conn.release(id, j.pri, j.delay)
        j.release
      end

      # clear up
      for state in @@states do
        @@jobs["#{state}"].clear
      end
    end
  end
end
